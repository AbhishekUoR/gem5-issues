= gem5 issues
:idprefix:
:idseparator: -
:sectanchors:
:sectlinks:
:sectnumlevels: 6
:sectnums:
:toc: macro
:toclevels: 6
:toc-title:

gem5 issue tracker, HOWTOs, FAQs, and architecture overview.

toc::[]

== About

This repository has two functions:

* be an <<issue-tracker>> for gem5
* contain a <<cheatsheet>> of how to do common stuff in gem5

=== Issue tracker

Completely unofficial gem5 issue tracker for https://github.com/gem5/gem5 , the mailing list is the only official one: http://gem5.org/Mailing_Lists Request for official GitHub tracker was declined:

* https://www.mail-archive.com/gem5-dev@gem5.org/msg24951.html
* https://github.com/cirosantilli-work/gem5-issues/issues/3

go ping the mailing list thread if you want it.

Maintained on a best effort basis, I will try to label, reproduce and close bugs reported.

Anyone is welcome to open bugs here, but they will likely not be seen by any devs except me.

For usage questions, prefer the Stack Overflow gem5 tag: https://stackoverflow.com/questions/tagged/gem5 although it will also likely not be seen by the other main devs currently either.

Double posting here in addition to the official tracker is encouraged.

=== Cheatsheet

Linux kernel related things and some more will be kept at: https://github.com/cirosantilli/linux-kernel-module-cheat#gem5 only baremetal, internals and other Linux-agnostic stuff will be documented here.

These cheats will often be summaries of solved issues, or smaller things which we didn't think deserve an issue, or that we were able to solve by ourselves without creating an issue.

== How to get a graph graphical representation of the topology of the system being simulated?

....
pip install --user pydot
....

then run gem5 normally, and:

....
xdg-open m5out/config.dot.pdf
....

As in http://gem5.org/wiki/images/0/0e/ASPLOS2017_gem5_tutorial.pdf page 25.

== How does gem5 find its Python configuration imports?

I think it is just done with `PYTHONPATH`, nothing is hardcoded on the executable.

However, many of the scripts add stuff to the `PYTHONPATH`, so that you can just point to them, and they will import the relative files automatically.

E.g. `fs.py` contains https://github.com/gem5/gem5/blob/49f96e7b77925837aa5bc84d4c3453ab5f07408e/configs/example/fs.py#L55:

....
addToPath('../')
....

== How are the arm disk images generated?

TODO

The ones present at http://www.gem5.org/dist/current/arm/ with filenames of type:

* `arm-system-YYYY-MM.tar.xz`
* `aarch-system-YYYY-MM.tar.xz`

I want to know what they contain in detail, and how to modify them.

== How to specify the bootloader explicitly without M5_PATH in fs.py?

TODO

I just want to point to `boot_emm.arm` directly, and not have it be found with the annoying environment `M5_OUT` variable.

Does not seem possible as of 49f96e7b77925837aa5bc84d4c3453ab5f07408e.

== How to view and modify DTBs?

Best approach: we have automatic DTB generation as of 49f96e7b77925837aa5bc84d4c3453ab5f07408e:

* `fs.py`: `--generate-dtb`, but there is a bug: https://github.com/cirosantilli-work/gem5-issues/issues/18
* `fs_bigLITTLE.py`: if you don't pass `--dtb`, auto-generation is used automatically

Direct approach: https://stackoverflow.com/questions/14000736/tool-to-visualize-the-device-tree-file-dtb-used-by-the-linux-kernel/39931834#39931834

Indirect: the DTBs are generated from dts files in-tree with Makefiles, e.g. in 49f96e7b77925837aa5bc84d4c3453ab5f07408e:

* `system/arm/dt/armv8_big_little.dts`
* `system/arm/dt/Makefile`

so you can just hack them up and rebuild.

Related: https://www.mail-archive.com/gem5-users@gem5.org/msg15636.html

== How to build gem5 with ccache?

`CXX='ccache c++'` does not work, `CXX=/my/path/to/ccache/wrapper/c++` does not work, the only thing that works it to put `c++` it in your `PATH` as a ccache gem5 symlink:

....
export PATH="/usr/lib/ccache:${PATH}" scons
....

== Source code analysis

=== Entry point

The main is at: `src/sim/main.cc`

....
ret = initM5Python();
....

src/sim/init.cc:

....
230 int
231 initM5Python()
232 {
233     EmbeddedPyBind::initAll();
234     return EmbeddedPython::initAll();
235 }
....

`initAll` basically just initializes the `_m5` Python object, which is used across multiple `.py`.

Back on `main`:

....
ret = m5Main(argc, argv);
....

which goes to:

....
result = PyRun_String(*command, Py_file_input, dict, dict);
....

with commands looping over:

....
import m5
m5.main()
....

which leads into:

....
src/python/m5/main.py#main
....

which finally calls your config file like `fs.py` with:

....
filename = sys.argv[0]
filedata = file(filename, 'r').read()
filecode = compile(filedata, filename, 'exec')
[...]
exec filecode in scope
....

=== How gem5 interacts with Python?

It uses pybind11.

The C++ executable both:

* starts running the Python executable
* provides Python classes written in C++ for that Python code to use

An example of this can be found at:

* https://docs.python.org/2/extending/embedding.html#extending-embedded-python
* https://github.com/pybind/pybind11/tree/v2.2.3/tests/test_embed

Then, then gem5 magic `SimObject` class adds some crazy stuff on top of it further... what a mess. In particular, it auto generates `params/` headers.

Let's study `BadDevice` for example:

`src/dev/BadDevice.py` defines `devicename`:

....
class BadDevice(BasicPioDevice):
    type = 'BadDevice'
    cxx_header = "dev/baddev.hh"
    devicename = Param.String("Name of device to error on")
....

`build/ARM/params/BadDevice.hh` (auto-generated):

....
#ifndef __PARAMS__BadDevice__
#define __PARAMS__BadDevice__

class BadDevice;

#include <cstddef>
#include <string>

#include "params/BasicPioDevice.hh"

struct BadDeviceParams
    : public BasicPioDeviceParams
{
    BadDevice * create();
    std::string devicename;
};

#endif // __PARAMS__BadDevice__
....

`src/dev/baddev.hh` then uses the parameters on the constructor:

....
class BadDevice : public BasicPioDevice
{
  private:
    std::string devname;

  public:
    typedef BadDeviceParams Params;

  protected:
    const Params *
    params() const
    {
        return dynamic_cast<const Params *>(_params);
    }

  public:
     /**
      * Constructor for the Baddev Class.
      * @param p object parameters
      * @param a base address of the write
      */
    BadDevice(Params *p);
....

`src/dev/alpha/Tsunami.py` shows the assignment from Python is:

....
    fb = BadDevice(pio_addr=0x801fc0003d0, devicename='FrameBuffer')
....

`src/dev/baddev.cc` then uses the parameter:

....
BadDevice::BadDevice(Params *p)
    : BasicPioDevice(p, 0x10), devname(p->devicename)
{
}
....

TODO: why is this needed? pybind11 seems to handle constructor arguments just fine:

* https://github.com/pybind/pybind11/blob/v2.2.3/tests/test_class.py#L77
* https://github.com/pybind/pybind11/blob/v2.2.3/tests/test_class.cpp#L41

TODO: how does this work at all? With pybind11 examples, a Python module is generated from `C++`. But here we have both a Python class, and a C++ class, so who defines the module?

Tested on gem5 59b6062b297c7cf20ae562978e37e7b373844220.

=== Why everything under src/python requires a rebuild even though it is Python?

TODO. Very annoying.
